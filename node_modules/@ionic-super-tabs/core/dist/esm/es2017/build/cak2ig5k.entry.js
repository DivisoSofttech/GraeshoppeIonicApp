import { h } from '../supertabs.core.js';

import { a as DEFAULT_CONFIG, b as scrollEl, c as pointerCoord, d as checkGesture, e as getNormalizedScrollX } from './chunk-39d8d03b.js';

class SuperTabComponent {
    async getRootScrollableEl() {
        if (this.el.scrollHeight > this.el.clientHeight) {
            return this.el;
        }
        const ionContent = this.el.querySelector('ion-content');
        if (ionContent) {
            return ionContent.getScrollElement();
        }
        return null;
    }
    render() {
        return h("slot", null);
    }
    static get is() { return "super-tab"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "el": {
            "elementRef": true
        },
        "getRootScrollableEl": {
            "method": true
        }
    }; }
    static get style() { return ":host{height:100%;position:relative;display:block;overflow:hidden;z-index:1;-ms-flex-negative:0;flex-shrink:0;-ms-flex-positive:0;flex-grow:0;width:var(--super-tab-width,100vw);-webkit-transform:translateZ(0);transform:translateZ(0)}ion-nav{height:100%;max-height:100%}ion-nav,ion-nav>.ion-page{position:absolute}"; }
}

class SuperTabsComponent {
    constructor() {
        this.activeTabIndex = 0;
        this._config = DEFAULT_CONFIG;
    }
    setConfig(config) {
        this._config = Object.assign({}, DEFAULT_CONFIG, config);
        this.container && (this.container.config = this._config);
        this.toolbar && (this.toolbar.config = this._config);
    }
    selectTab(index, animate = true) {
        if (this.container) {
            this.container.moveContainerByIndex(index, animate);
        }
        if (this.toolbar) {
            this.toolbar.setActiveTab(index);
        }
    }
    onConfigChange(config) {
        this.setConfig(config);
    }
    onContainerSelectedTabChange(ev) {
        if (this.toolbar) {
            this.toolbar.setSelectedTab(ev.detail);
        }
    }
    onContainerActiveTabChange(ev) {
        const index = ev.detail;
        this.tabChange.emit({
            changed: index !== this.activeTabIndex,
            index,
        });
        this.activeTabIndex = index;
        this.toolbar && this.toolbar.setActiveTab(index);
    }
    onToolbarButtonClick(ev) {
        const { index } = ev.detail;
        this.container && this.container.setActiveTabIndex(index);
        this.tabChange.emit({
            changed: index !== this.activeTabIndex,
            index,
        });
        this.activeTabIndex = index;
    }
    indexChildren() {
        const container = this.el.querySelector('super-tabs-container');
        const toolbar = this.el.querySelector('super-tabs-toolbar');
        if (container && this.container !== container) {
            this.container = container;
            container.config = this._config;
        }
        if (toolbar && this.toolbar !== toolbar) {
            this.toolbar = toolbar;
            toolbar.config = this._config;
        }
    }
    componentDidUpdate() {
        this.indexChildren();
        this.selectTab(this.activeTabIndex);
    }
    componentWillLoad() {
        this.indexChildren();
        this.selectTab(this.activeTabIndex);
        this.el.addEventListener('selectedTabIndexChange', this.onContainerSelectedTabChange.bind(this));
        this.el.addEventListener('activeTabIndexChange', this.onContainerActiveTabChange.bind(this));
        this.el.addEventListener('buttonClick', this.onToolbarButtonClick.bind(this));
    }
    render() {
        return [
            h("slot", { name: "top" }),
            h("slot", null),
            h("slot", { name: "bottom" }),
        ];
    }
    static get is() { return "super-tabs"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "activeTabIndex": {
            "type": Number,
            "attr": "active-tab-index",
            "reflectToAttr": true,
            "mutable": true
        },
        "config": {
            "type": "Any",
            "attr": "config",
            "watchCallbacks": ["onConfigChange"]
        },
        "el": {
            "elementRef": true
        },
        "selectTab": {
            "method": true
        },
        "setConfig": {
            "method": true
        }
    }; }
    static get events() { return [{
            "name": "tabChange",
            "method": "tabChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host{-webkit-box-sizing:content-box;box-sizing:content-box;height:100%;max-height:100%;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;overflow:hidden;z-index:1;position:relative;contain:layout size style}"; }
}

class SuperTabsContainerComponent {
    constructor() {
        this.swipeEnabled = true;
        this.autoScrollTop = false;
        this.tabs = [];
        this._activeTabIndex = 0;
        this.leftThreshold = 0;
        this.rightThreshold = 0;
        this.scrollWidth = 0;
        this.clientWidth = 0;
    }
    componentDidLoad() {
        this.indexTabs();
    }
    componentDidUpdate() {
        this.indexTabs();
    }
    moveContainerByIndex(index, animate) {
        const scrollX = this.indexToPosition(index);
        return this.moveContainer(scrollX, animate);
    }
    moveContainer(scrollX, animate) {
        scrollEl(this.el, scrollX, 0, animate ? this.config.transitionDuration : 0, this.queue);
    }
    setActiveTabIndex(index) {
        if (this._activeTabIndex === index) {
            if (!this.autoScrollTop) {
                return;
            }
            const current = this.tabs[this._activeTabIndex];
            this.queue.read(() => {
                current.getRootScrollableEl()
                    .then(el => {
                    if (el) {
                        this.queue.write(() => {
                            scrollEl(el, 0, 0, this.config.transitionDuration, this.queue);
                        });
                    }
                });
            });
        }
        this.moveContainerByIndex(index, true);
        this.updateActiveTabIndex(index, false);
    }
    updateActiveTabIndex(index, emit = true) {
        this._activeTabIndex = index;
        emit && this.activeTabIndexChange.emit(this._activeTabIndex);
    }
    updateSelectedTabIndex(index) {
        if (index === this._selectedTabIndex) {
            return;
        }
        this._selectedTabIndex = index;
        this.selectedTabIndexChange.emit(this._selectedTabIndex);
    }
    async onWindowResize() {
        this.indexTabs();
    }
    async onTouchStart(ev) {
        if (!this.swipeEnabled) {
            return;
        }
        let avoid = false;
        let element = ev.target;
        if (element) {
            do {
                if (typeof element.getAttribute === 'function' && element.getAttribute('avoid-super-tabs')) {
                    this.shouldCapture = false;
                    return;
                }
                element = element.parentElement;
            } while (element && !avoid);
        }
        const coords = pointerCoord(ev);
        const vw = this.clientWidth;
        if (coords.x < this.leftThreshold || coords.x > vw - this.rightThreshold) {
            this.shouldCapture = false;
            return;
        }
        this.initialCoords = coords;
        if (this.config.shortSwipeDuration > 0) {
            this.initialTimestamp = window.performance.now();
        }
        this.lastPosX = coords.x;
    }
    async onTouchMove(ev) {
        if (!this.swipeEnabled) {
            return;
        }
        this.queue.read(() => {
            const coords = pointerCoord(ev);
            if (!this.isDragging) {
                if (typeof this.shouldCapture !== 'boolean') {
                    this.shouldCapture = checkGesture(coords, this.initialCoords, this.config);
                }
                if (this.shouldCapture !== true) {
                    return;
                }
                this.isDragging = true;
            }
            if (!this.config.allowElementScroll) {
                ev.stopPropagation();
                ev.preventDefault();
            }
            const deltaX = this.lastPosX - coords.x;
            if (deltaX === 0) {
                return;
            }
            const scrollLeft = this.el.scrollLeft;
            const scrollX = getNormalizedScrollX(this.el, deltaX);
            if (scrollX === scrollLeft) {
                return;
            }
            this.updateSelectedTabIndex(this.positionToIndex(scrollX));
            this.queue.write(() => {
                this.lastPosX = coords.x;
                this.moveContainer(scrollX, false);
            });
        });
    }
    async onTouchEnd(ev) {
        if (!this.swipeEnabled) {
            return;
        }
        const coords = pointerCoord(ev);
        if (this.shouldCapture === true) {
            const deltaTime = window.performance.now() - this.initialTimestamp;
            const shortSwipe = this.config.shortSwipeDuration > 0 && deltaTime <= this.config.shortSwipeDuration;
            const shortSwipeDelta = coords.x - this.initialCoords.x;
            this.queue.read(() => {
                let selectedTabIndex = this.calcSelectedTab();
                const expectedTabIndex = Math.round(selectedTabIndex);
                if (shortSwipe && expectedTabIndex === this._activeTabIndex) {
                    selectedTabIndex += shortSwipeDelta > 0 ? -1 : 1;
                }
                selectedTabIndex = this.normalizeSelectedTab(selectedTabIndex);
                this.updateActiveTabIndex(selectedTabIndex);
                this.queue.write(() => {
                    this.moveContainer(this.indexToPosition(selectedTabIndex), true);
                });
            });
        }
        this.isDragging = false;
        this.shouldCapture = void 0;
    }
    indexTabs() {
        this.queue.read(() => {
            this.scrollWidth = this.el.scrollWidth;
            this.clientWidth = this.el.clientWidth;
            const tabs = this.el.querySelectorAll('super-tab');
            const tabsArray = [];
            for (let i = 0; i < tabs.length; i++) {
                tabsArray.push(tabs[i]);
            }
            this.tabs = tabsArray;
        });
        if (this.config.sideMenu === 'both' || this.config.sideMenu === 'left') {
            this.leftThreshold = this.config.sideMenuThreshold;
        }
        if (this.config.sideMenu === 'both' || this.config.sideMenu === 'right') {
            this.rightThreshold = this.config.sideMenuThreshold;
        }
    }
    calcSelectedTab() {
        const tabsWidth = this.scrollWidth;
        const tabWidth = this.clientWidth;
        const minX = 0;
        const maxX = tabsWidth - tabWidth;
        const scrollX = Math.max(minX, Math.min(maxX, this.el.scrollLeft));
        return this.positionToIndex(scrollX);
    }
    positionToIndex(scrollX) {
        const tabWidth = this.clientWidth;
        return scrollX / tabWidth;
    }
    indexToPosition(scrollX) {
        const tabWidth = this.clientWidth;
        return scrollX * tabWidth;
    }
    normalizeSelectedTab(index) {
        const tabsWidth = this.scrollWidth;
        const tabWidth = this.clientWidth;
        const minX = 0;
        const maxX = tabsWidth - tabWidth;
        const scrollX = Math.max(minX, Math.min(maxX, tabWidth * Math.round(index)));
        return scrollX / tabWidth;
    }
    render() {
        return h("slot", null);
    }
    static get is() { return "super-tabs-container"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "autoScrollTop": {
            "type": Boolean,
            "attr": "auto-scroll-top"
        },
        "config": {
            "type": "Any",
            "attr": "config",
            "mutable": true
        },
        "el": {
            "elementRef": true
        },
        "moveContainer": {
            "method": true
        },
        "moveContainerByIndex": {
            "method": true
        },
        "queue": {
            "context": "queue"
        },
        "setActiveTabIndex": {
            "method": true
        },
        "swipeEnabled": {
            "type": Boolean,
            "attr": "swipe-enabled"
        }
    }; }
    static get events() { return [{
            "name": "activeTabIndexChange",
            "method": "activeTabIndexChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "selectedTabIndexChange",
            "method": "selectedTabIndexChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "window:resize",
            "method": "onWindowResize",
            "passive": true
        }, {
            "name": "touchstart",
            "method": "onTouchStart",
            "passive": true
        }, {
            "name": "touchmove",
            "method": "onTouchMove"
        }, {
            "name": "touchend",
            "method": "onTouchEnd",
            "passive": true
        }]; }
    static get style() { return ":host{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;min-width:100%;-ms-flex:1 1 auto;flex:1 1 auto;position:relative;-webkit-box-sizing:content-box;box-sizing:content-box;width:100%;overflow:hidden;-webkit-transform:translateZ(0);transform:translateZ(0);-ms-touch-action:pan-y;touch-action:pan-y;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;will-change:scroll-position}"; }
}

export { SuperTabComponent as SuperTab, SuperTabsComponent as SuperTabs, SuperTabsContainerComponent as SuperTabsContainer };
